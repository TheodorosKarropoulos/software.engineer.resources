## Architectural Patterns

- Monolithic architecture: A monolithic architecture is a traditional approach in which the entire application is built as a single, self-contained unit. All components of the application, including the user interface, business logic, and data storage, are combined into a single codebase.
- Microservices architecture: A microservices architecture is a modern approach in which the application is broken down into small, independent components, or "microservices," that communicate with each other through APIs. Each microservice is responsible for a specific function, and they can be developed, deployed, and scaled independently.
- Layered architecture: A layered architecture is a design in which the application is divided into logical layers, such as a presentation layer, a business logic layer, and a data storage layer. Each layer has a specific responsibility, and they are separated by clear interfaces.
- Client-server architecture: A client-server architecture is a design in which the application is divided into two parts: a client, which is responsible for presenting data to the user and handling user input, and a server, which is responsible for processing requests and storing data.
- Event-driven architecture: An event-driven architecture is a design in which the application is built around a series of events that trigger certain actions. The application listens for events, and when an event occurs, it performs the appropriate action.
- Model-View-Controller (MVC): An MVC architecture is a design pattern in which the application is divided into three main components: the model, which represents the data and business logic; the view, which represents the user interface; and the controller, which handles user input and coordinates between the model and view.
- Pipe and Filter: A pipe and filter architecture is a design in which the application is divided into a series of independent filters that transform the data as it passes through them. Each filter performs a specific transformation, and the output of one filter becomes the input of the next.
- Event-Sourcing: An event-sourcing architecture is a design in which the application stores all changes to the system as a series of events, rather than storing the current state of the system. This allows the system to be reconstructed from the events at any point in time.
- Service-Oriented Architecture (SOA): A service-oriented architecture is a design in which the application is divided into a collection of independent services that communicate with each other through APIs. Each service is responsible for a specific function, and they can be developed, deployed, and scaled independently.
- Serverless Architecture: A serverless architecture is a design in which the application is built using cloud-based functions that are triggered by events. The cloud provider is responsible for scaling and managing the infrastructure, allowing the developer to focus on writing code.
- Object-Oriented Architecture: An object-oriented architecture is a design in which the application is built using objects, which are self-contained units that combine data and behavior. Objects can interact with each other through methods, and they can be organized into inheritance hierarchies.
- Data-Centric Architecture: A data-centric architecture is a design in which the application is built around a central data store, and the data is the primary focus of the system. The application uses various mechanisms, such as database queries and data transformation pipelines, to access and manipulate the data.
- Publish-Subscribe Architecture: A publish-subscribe architecture is a design in which the application is built around a message bus, and components of the system publish messages to the bus and subscribe to messages from the bus. This allows components to communicate with each other asynchronously, without needing to know about each other directly.
- Space-Based Architecture: A space-based architecture is a design in which the application is built around a shared memory space, and components of the system interact with the space by reading and writing data to it. This allows components to communicate with each other in a decoupled, asynchronous manner.
- Representational State Transfer (REST) Architecture: A REST architecture is a design for building web APIs that follows a set of principles for creating scalable, maintainable, and reusable APIs. REST APIs use HTTP methods and resources to expose data and functionality, and they are based on the idea of representing the state of a system through a set of resources that can be accessed and manipulated using HTTP requests.
- Hexagonal Architecture (Ports and Adapters): Separates an application into inner and outer layers. The core business logic (hexagon) is independent of external concerns (adapters), allowing for easy integration with different technologies or frameworks.
- CQRS (Command Query Responsibility Segregation): Separates read and write operations in a system. Commands handle updates and modifications, while queries handle data retrieval. This pattern can improve performance and scalability by optimizing for specific use cases.
- GraphQL Architecture: Provides a flexible and efficient alternative to traditional REST APIs. Clients can request only the data they need, reducing over-fetching and under-fetching of data. GraphQL allows clients to shape responses according to their requirements.
- Clean Architecture: Emphasizes separation of concerns by organizing code into concentric circles or layers, with the innermost layer containing the core business logic. Dependencies flow inward, promoting testability and maintainability.